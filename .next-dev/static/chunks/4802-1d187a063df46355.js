"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4802],{11727:(t,e,i)=>{i.d(e,{$:()=>o,s:()=>a});var s=i(51788),r=i(96069),n=i(745),a=class extends r.k{#t;#e;#i;#s;constructor(t){super(),this.#t=t.client,this.mutationId=t.mutationId,this.#i=t.mutationCache,this.#e=[],this.state=t.state||o(),this.setOptions(t.options),this.scheduleGc()}setOptions(t){this.options=t,this.updateGcTime(this.options.gcTime)}get meta(){return this.options.meta}addObserver(t){this.#e.includes(t)||(this.#e.push(t),this.clearGcTimeout(),this.#i.notify({type:"observerAdded",mutation:this,observer:t}))}removeObserver(t){this.#e=this.#e.filter(e=>e!==t),this.scheduleGc(),this.#i.notify({type:"observerRemoved",mutation:this,observer:t})}optionalRemove(){this.#e.length||("pending"===this.state.status?this.scheduleGc():this.#i.remove(this))}continue(){return this.#s?.continue()??this.execute(this.state.variables)}async execute(t){let e=()=>{this.#r({type:"continue"})},i={client:this.#t,meta:this.options.meta,mutationKey:this.options.mutationKey};this.#s=(0,n.II)({fn:()=>this.options.mutationFn?this.options.mutationFn(t,i):Promise.reject(Error("No mutationFn found")),onFail:(t,e)=>{this.#r({type:"failed",failureCount:t,error:e})},onPause:()=>{this.#r({type:"pause"})},onContinue:e,retry:this.options.retry??0,retryDelay:this.options.retryDelay,networkMode:this.options.networkMode,canRun:()=>this.#i.canRun(this)});let s="pending"===this.state.status,r=!this.#s.canStart();try{if(s)e();else{this.#r({type:"pending",variables:t,isPaused:r}),await this.#i.config.onMutate?.(t,this,i);let e=await this.options.onMutate?.(t,i);e!==this.state.context&&this.#r({type:"pending",context:e,variables:t,isPaused:r})}let n=await this.#s.start();return await this.#i.config.onSuccess?.(n,t,this.state.context,this,i),await this.options.onSuccess?.(n,t,this.state.context,i),await this.#i.config.onSettled?.(n,null,this.state.variables,this.state.context,this,i),await this.options.onSettled?.(n,null,t,this.state.context,i),this.#r({type:"success",data:n}),n}catch(e){try{throw await this.#i.config.onError?.(e,t,this.state.context,this,i),await this.options.onError?.(e,t,this.state.context,i),await this.#i.config.onSettled?.(void 0,e,this.state.variables,this.state.context,this,i),await this.options.onSettled?.(void 0,e,t,this.state.context,i),e}finally{this.#r({type:"error",error:e})}}finally{this.#i.runNext(this)}}#r(t){this.state=(e=>{switch(t.type){case"failed":return{...e,failureCount:t.failureCount,failureReason:t.error};case"pause":return{...e,isPaused:!0};case"continue":return{...e,isPaused:!1};case"pending":return{...e,context:t.context,data:void 0,failureCount:0,failureReason:null,error:null,isPaused:t.isPaused,status:"pending",variables:t.variables,submittedAt:Date.now()};case"success":return{...e,data:t.data,failureCount:0,failureReason:null,error:null,status:"success",isPaused:!1};case"error":return{...e,data:void 0,error:t.error,failureCount:e.failureCount+1,failureReason:t.error,isPaused:!1,status:"error"}}})(this.state),s.jG.batch(()=>{this.#e.forEach(e=>{e.onMutationUpdate(t)}),this.#i.notify({mutation:this,type:"updated",action:t})})}};function o(){return{context:void 0,data:void 0,error:null,failureCount:0,failureReason:null,isPaused:!1,status:"idle",variables:void 0,submittedAt:0}}},11809:(t,e,i)=>{i.d(e,{vt:()=>c});let s=t=>{let e,i=new Set,s=(t,s)=>{let r="function"==typeof t?t(e):t;if(!Object.is(r,e)){let t=e;e=(null!=s?s:"object"!=typeof r||null===r)?r:Object.assign({},e,r),i.forEach(i=>i(e,t))}},r=()=>e,n={setState:s,getState:r,getInitialState:()=>a,subscribe:t=>(i.add(t),()=>i.delete(t)),destroy:()=>{console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),i.clear()}},a=e=t(s,r,n);return n};var r=i(59693),n=i(90635);let{useDebugValue:a}=r,{useSyncExternalStoreWithSelector:o}=n,u=!1,l=t=>{"function"!=typeof t&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");let e="function"==typeof t?(t=>t?s(t):s)(t):t,i=(t,i)=>(function(t,e=t=>t,i){i&&!u&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),u=!0);let s=o(t.subscribe,t.getState,t.getServerState||t.getInitialState,e,i);return a(s),s})(e,t,i);return Object.assign(i,e),i},c=t=>t?l(t):l},65332:(t,e,i)=>{i.d(e,{n:()=>c});var s=i(59693),r=i(11727),n=i(51788),a=i(7453),o=i(14225),u=class extends a.Q{#t;#n=void 0;#a;#o;constructor(t,e){super(),this.#t=t,this.setOptions(e),this.bindMethods(),this.#u()}bindMethods(){this.mutate=this.mutate.bind(this),this.reset=this.reset.bind(this)}setOptions(t){let e=this.options;this.options=this.#t.defaultMutationOptions(t),(0,o.f8)(this.options,e)||this.#t.getMutationCache().notify({type:"observerOptionsUpdated",mutation:this.#a,observer:this}),e?.mutationKey&&this.options.mutationKey&&(0,o.EN)(e.mutationKey)!==(0,o.EN)(this.options.mutationKey)?this.reset():this.#a?.state.status==="pending"&&this.#a.setOptions(this.options)}onUnsubscribe(){this.hasListeners()||this.#a?.removeObserver(this)}onMutationUpdate(t){this.#u(),this.#l(t)}getCurrentResult(){return this.#n}reset(){this.#a?.removeObserver(this),this.#a=void 0,this.#u(),this.#l()}mutate(t,e){return this.#o=e,this.#a?.removeObserver(this),this.#a=this.#t.getMutationCache().build(this.#t,this.options),this.#a.addObserver(this),this.#a.execute(t)}#u(){let t=this.#a?.state??(0,r.$)();this.#n={...t,isPending:"pending"===t.status,isSuccess:"success"===t.status,isError:"error"===t.status,isIdle:"idle"===t.status,mutate:this.mutate,reset:this.reset}}#l(t){n.jG.batch(()=>{if(this.#o&&this.hasListeners()){let e=this.#n.variables,i=this.#n.context,s={client:this.#t,meta:this.options.meta,mutationKey:this.options.mutationKey};t?.type==="success"?(this.#o.onSuccess?.(t.data,e,i,s),this.#o.onSettled?.(t.data,null,e,i,s)):t?.type==="error"&&(this.#o.onError?.(t.error,e,i,s),this.#o.onSettled?.(void 0,t.error,e,i,s))}this.listeners.forEach(t=>{t(this.#n)})})}},l=i(74784);function c(t,e){let i=(0,l.jE)(e),[r]=s.useState(()=>new u(i,t));s.useEffect(()=>{r.setOptions(t)},[r,t]);let a=s.useSyncExternalStore(s.useCallback(t=>r.subscribe(n.jG.batchCalls(t)),[r]),()=>r.getCurrentResult(),()=>r.getCurrentResult()),c=s.useCallback((t,e)=>{r.mutate(t,e).catch(o.lQ)},[r]);if(a.error&&(0,o.GU)(r.options.throwOnError,[a.error]))throw a.error;return{...a,mutate:c,mutateAsync:a.mutate}}},68659:(t,e,i)=>{i.d(e,{Zr:()=>r});let s=t=>e=>{try{let i=t(e);if(i instanceof Promise)return i;return{then:t=>s(t)(i),catch(t){return this}}}catch(t){return{then(t){return this},catch:e=>s(e)(t)}}},r=(t,e)=>"getStorage"in e||"serialize"in e||"deserialize"in e?(console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),((t,e)=>(i,r,n)=>{let a,o,u={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:t=>t,version:0,merge:(t,e)=>({...e,...t}),...e},l=!1,c=new Set,h=new Set;try{a=u.getStorage()}catch(t){}if(!a)return t((...t)=>{console.warn(`[zustand persist middleware] Unable to update item '${u.name}', the given storage is currently unavailable.`),i(...t)},r,n);let d=s(u.serialize),p=()=>{let t,e=d({state:u.partialize({...r()}),version:u.version}).then(t=>a.setItem(u.name,t)).catch(e=>{t=e});if(t)throw t;return e},f=n.setState;n.setState=(t,e)=>{f(t,e),p()};let m=t((...t)=>{i(...t),p()},r,n),v=()=>{var t;if(!a)return;l=!1,c.forEach(t=>t(r()));let e=(null==(t=u.onRehydrateStorage)?void 0:t.call(u,r()))||void 0;return s(a.getItem.bind(a))(u.name).then(t=>{if(t)return u.deserialize(t)}).then(t=>{if(t)if("number"!=typeof t.version||t.version===u.version)return t.state;else{if(u.migrate)return u.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}}).then(t=>{var e;return i(o=u.merge(t,null!=(e=r())?e:m),!0),p()}).then(()=>{null==e||e(o,void 0),l=!0,h.forEach(t=>t(o))}).catch(t=>{null==e||e(void 0,t)})};return n.persist={setOptions:t=>{u={...u,...t},t.getStorage&&(a=t.getStorage())},clearStorage:()=>{null==a||a.removeItem(u.name)},getOptions:()=>u,rehydrate:()=>v(),hasHydrated:()=>l,onHydrate:t=>(c.add(t),()=>{c.delete(t)}),onFinishHydration:t=>(h.add(t),()=>{h.delete(t)})},v(),o||m})(t,e)):((t,e)=>(i,r,n)=>{let a,o={storage:function(t,e){let i;try{i=t()}catch(t){return}return{getItem:t=>{var e;let s=t=>null===t?null:JSON.parse(t,void 0),r=null!=(e=i.getItem(t))?e:null;return r instanceof Promise?r.then(s):s(r)},setItem:(t,e)=>i.setItem(t,JSON.stringify(e,void 0)),removeItem:t=>i.removeItem(t)}}(()=>localStorage),partialize:t=>t,version:0,merge:(t,e)=>({...e,...t}),...e},u=!1,l=new Set,c=new Set,h=o.storage;if(!h)return t((...t)=>{console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`),i(...t)},r,n);let d=()=>{let t=o.partialize({...r()});return h.setItem(o.name,{state:t,version:o.version})},p=n.setState;n.setState=(t,e)=>{p(t,e),d()};let f=t((...t)=>{i(...t),d()},r,n);n.getInitialState=()=>f;let m=()=>{var t,e;if(!h)return;u=!1,l.forEach(t=>{var e;return t(null!=(e=r())?e:f)});let n=(null==(e=o.onRehydrateStorage)?void 0:e.call(o,null!=(t=r())?t:f))||void 0;return s(h.getItem.bind(h))(o.name).then(t=>{if(t)if("number"!=typeof t.version||t.version===o.version)return[!1,t.state];else{if(o.migrate)return[!0,o.migrate(t.state,t.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}return[!1,void 0]}).then(t=>{var e;let[s,n]=t;if(i(a=o.merge(n,null!=(e=r())?e:f),!0),s)return d()}).then(()=>{null==n||n(a,void 0),a=r(),u=!0,c.forEach(t=>t(a))}).catch(t=>{null==n||n(void 0,t)})};return n.persist={setOptions:t=>{o={...o,...t},t.storage&&(h=t.storage)},clearStorage:()=>{null==h||h.removeItem(o.name)},getOptions:()=>o,rehydrate:()=>m(),hasHydrated:()=>u,onHydrate:t=>(l.add(t),()=>{l.delete(t)}),onFinishHydration:t=>(c.add(t),()=>{c.delete(t)})},o.skipHydration||m(),a||f})(t,e)},69353:(t,e,i)=>{t.exports=i(81636)},81636:(t,e,i)=>{var s=i(59693),r="function"==typeof Object.is?Object.is:function(t,e){return t===e&&(0!==t||1/t==1/e)||t!=t&&e!=e},n=s.useState,a=s.useEffect,o=s.useLayoutEffect,u=s.useDebugValue;function l(t){var e=t.getSnapshot;t=t.value;try{var i=e();return!r(t,i)}catch(t){return!0}}var c="undefined"==typeof window||void 0===window.document||void 0===window.document.createElement?function(t,e){return e()}:function(t,e){var i=e(),s=n({inst:{value:i,getSnapshot:e}}),r=s[0].inst,c=s[1];return o(function(){r.value=i,r.getSnapshot=e,l(r)&&c({inst:r})},[t,i,e]),a(function(){return l(r)&&c({inst:r}),t(function(){l(r)&&c({inst:r})})},[t]),u(i),i};e.useSyncExternalStore=void 0!==s.useSyncExternalStore?s.useSyncExternalStore:c},82403:(t,e,i)=>{var s=i(59693),r=i(69353),n="function"==typeof Object.is?Object.is:function(t,e){return t===e&&(0!==t||1/t==1/e)||t!=t&&e!=e},a=r.useSyncExternalStore,o=s.useRef,u=s.useEffect,l=s.useMemo,c=s.useDebugValue;e.useSyncExternalStoreWithSelector=function(t,e,i,s,r){var h=o(null);if(null===h.current){var d={hasValue:!1,value:null};h.current=d}else d=h.current;var p=a(t,(h=l(function(){function t(t){if(!u){if(u=!0,a=t,t=s(t),void 0!==r&&d.hasValue){var e=d.value;if(r(e,t))return o=e}return o=t}if(e=o,n(a,t))return e;var i=s(t);return void 0!==r&&r(e,i)?(a=t,e):(a=t,o=i)}var a,o,u=!1,l=void 0===i?null:i;return[function(){return t(e())},null===l?void 0:function(){return t(l())}]},[e,i,s,r]))[0],h[1]);return u(function(){d.hasValue=!0,d.value=p},[p]),c(p),p}},90635:(t,e,i)=>{t.exports=i(82403)}}]);